<html>
	<head>
    	<meta charset="UTF-8">
    	<title>Work Test</title>
    <style>
      body { background-color: #000000; }
      canvas { background-color: #222222; }
    </style>	
	</head>
	
	<body onload="init()">
		<div align="center">
			<canvas id="game-canvas" width="1200" height="650"></canvas>
		</div>

		<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.0.0/pixi.min.js"></script>
		<script>
			var dragBool = false;
			var gameOver = false;
			var newPosition;
			var player;

			var missilesShot = [];
			var enemiesSpawned = [];
			
			var missileCount = 0; //idx = count--;
			var enemyCount = 0; //idx = count--;

		    function init() {
		    	var interactive = true;
		    	stage = new PIXI.Container(); //represents a collection of display objects as well as the stage (display object)
		    	renderer = PIXI.autoDetectRenderer( //uses WebGLRenderer by default, if fail, uses canvasRenderer
			    document.getElementById("game-canvas").width,
			    document.getElementById("game-canvas").height,
			    {view:document.getElementById("game-canvas")}
			);



		    //far background image
		    var farTexture = PIXI.Texture.fromImage("images/bg-far.jpg");
			far = new PIXI.extras.TilingSprite(
					farTexture, 
					1200,
  					650
				);

			far.position.x = 0;
			far.position.y = 0;
			far.tilePosition.x = 0;
    		far.tilePosition.y = 0;
			stage.addChild(far);

			//mid background image
			var midTexture = PIXI.Texture.fromImage("images/Building.png");
			mid = new PIXI.extras.TilingSprite(
					midTexture, 
					1200,
  					650
				);
			mid.position.x = 0;
			mid.position.y = 0;
			mid.tilePosition.x = 0;
			mid.tilePosition.y = 0;
			stage.addChild(mid);

			//player image
			var playerTexture = PIXI.Texture.fromImage('images/player.png');
			player = new PIXI.Sprite(playerTexture);
			player.interactive = true;
			
    		player.anchor.set(0.5);
			player.scale.set(0.8);
			player.on('mousedown', onDragStart).on('mousemove', onDragMove);

			player.position.x = 200;
			player.position.y = 540; //540-max 400-min
			stage.addChild(player);




			//renderer.render(stage);
				if(gameOver==false){
					requestAnimationFrame(update);  
		   	 	}
		    }

		    function onDragStart(event){
			    // store a reference to the data
			    // the reason for this is because of multitouch
			    // we want to track the movement of this particular touch
			    this.data = event.data;

			    //this.alpha = 0.5;
			    newPosition = this.data.getLocalPosition(this.parent);
			    if(dragBool==true){
			    	//console.log("shoot!");
			    	shootMissile();
			    }
			    else{
			    	dragBool = true;
			    	console.log("dragging enabled");
			    	this.dragging = dragBool;
			    	
			        if (this.dragging){
				        newPosition = this.data.getLocalPosition(this.parent);
				        this.position.x = newPosition.x;
				        this.position.y = newPosition.y;
				        //console.log("start: "+newPosition.y);
			    	}
			    	spawnEnemies();
			    	
				}

			}

			function stopMissile(id){
				cancelAnimationFrame(id);
				id = undefined;
			}

			function shootMissile(){
				console.log("shoot!");
				var missileTexture = PIXI.Texture.fromImage("images/missile.png");
				var missile = new PIXI.Sprite(missileTexture);
				missile.position.x = newPosition.x - 25;
				missile.position.y = newPosition.y - 90;
				stage.addChild(missile);
				missilesShot.push(missile);
				missileCount++;
				var missileIdx = missileCount - 1;
				//console.log(missileIdx);
				requestAnimationFrame(function updateMissiles() {
		            

		            missile.position.y -= 10.0;
		            missilesShot[missileIdx].position.y = missile.position.y; //update coordinates in the array
					
					if(missile.position.y < 0){ //remove missile sprite
						
						stage.removeChild(missile);
						missile = null;
						
						//missileCount--;
						//stopMissile(requestAnimationFrame(updateMissiles)); //not working?
					}
					
					//checks for the collision with enemy ships
					var eIdx = enemyCount - 1;
						if(missilesShot[missileIdx].position.y >= (enemiesSpawned[eIdx].position.y - 5) && missilesShot[missileIdx].position.y <= (enemiesSpawned[eIdx].position.y + 5) && missilesShot[missileIdx].position.x >= (enemiesSpawned[eIdx].position.x - 30) && missilesShot[missileIdx].position.x <= (enemiesSpawned[eIdx].position.x + 30)){
							
							stage.removeChild(missilesShot[missileIdx]);
							stage.removeChild(enemiesSpawned[eIdx]);
							console.log("enemiesSpawned: "+enemiesSpawned.length);
							//enemiesSpawned.shift();
						}
					
					renderer.render(stage);

					return requestAnimationFrame(updateMissiles);
					
		        });
							
			}

			function spawnEnemies(){
				
					//console.log("spawning enemies!");
					var enemyTexture = PIXI.Texture.fromImage("images/enemy.png");
					var enemy = new PIXI.Sprite(enemyTexture);
					enemy.scale.set(0.8);
					enemy.position.x = Math.floor((Math.random() * 1000) + 50);
					//console.log("enemy "+enemy.position.x);
					//enemy.position.x = 200;
					enemy.position.y = 0;
					stage.addChild(enemy);
					enemiesSpawned.push(enemy);
					enemyCount++;
					var enemyIdx = enemyCount - 1;
					//console.log(enemiesSpawned[enemyCount-=1].position.y);
					requestAnimationFrame(function updateEnemies() {
			            

			            enemy.position.y += 6.0;
			            //console.log("here: "+enemiesSpawned[enemyCount-=1].position.y);
			            enemiesSpawned[enemyIdx].position.y = enemy.position.y; //update coordinates in the array

			            if(enemy.position.y > 600){ //when enemy reaches bottom
			            	//enemiesSpawned.shift();
			            	
			            	stage.removeChild(enemy);
			            	enemy = null;
			            }			            
			            else if(newPosition.y-5 <= enemy.position.y && enemy.position.y <= newPosition.y+5 && newPosition.x-50 <= enemy.position.x && enemy.position.x <= newPosition.x+50){ //when enemy collides with player
			            	console.log("game over");
			            	//alert("game over");
			            	gameOver = true;
			            	stage.removeChild(player);
			            	stage.removeChild(enemy);
			            	
			            }

			            if(gameOver == false){
							renderer.render(stage);
							return requestAnimationFrame(updateEnemies);
						}
						else{
							return 0;
						}
			        });
			    if(gameOver==false){    
					setTimeout(spawnEnemies, 2000);
				}
			}

			function onDragEnd(){
			    this.alpha = 1;

			    this.dragging = false;

			    // set the interaction data to null
			    this.data = null;
			}

			function onDragMove(){
			    if (this.dragging)
			    {
			    	
			        newPosition = this.data.getLocalPosition(this.parent);
			        this.position.x = newPosition.x;
			        this.position.y = newPosition.y;
			        //console.log("player "+newPosition.x);

			    }
			}

		    function update() {
				far.tilePosition.x -= 0.208;
				mid.tilePosition.x -= 0.64;
				
				
				renderer.render(stage);

				requestAnimationFrame(update);
			
				
			}

			
		</script>  
	</body>
</html>